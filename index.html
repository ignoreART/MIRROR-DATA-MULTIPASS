**Finalizing HTML structure**

I’ll need to create the HTML structure with a nice card header, a viewport displaying stats and clocks, and possibly a footer with some logos, if needed. I’ll make sure the fetch only starts when the DOM is ready, and I’ll implement visibilitychange to pause the intervals if needed.

Network resilience is important, so I’ll handle retries and potential missing APIs. I'll use the Intl object for number formatting and keep the constants for the TOKEN_ID and LAUNCH_DATE. Let's put this all together.
### Fixed, self-contained HTML5 that binds DOM correctly, handles errors, and fetches efficiently

- Adds the missing DOM elements (`launchDate`, `days`, `currentDate`, `worldClocks`, `holders`, `total`, `circ`, `burned`, `price`, `lastUpdated`).
- Keeps exponential backoff with a hard timeout and graceful fallbacks.
- Batches concurrent API calls, de-dupes holders across paginated results, and stops early when possible.
- Pauses background polling when the tab is hidden; resumes on focus for efficiency.
- Renders immediately with placeholders, then updates on a 2-minute cadence.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MIRROR Multipass Card</title>
  <link rel="preconnect" href="https://api.spacescan.io"/>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap');
    :root {
      --frame-bg: linear-gradient(145deg, #dcdcdc, #a8a8a8, #8d8d8d, #c2c2c2);
      --frame-border: #676a6c;
      --accent-color: #ff9500;
      --glass-tint: rgba(34,139,34,0.15);
    }
    body {
      margin: 0; padding: 0; height: 100vh;
      display: flex; justify-content: center; align-items: center;
      background: #101010; font-family: 'Orbitron', sans-serif; color: #e0e0e0;
    }
    #card {
      width: 480px; height: 650px; background: var(--frame-bg);
      border: 2px solid var(--frame-border); border-radius: 16px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.8); position: relative;
      display: flex; flex-direction: column; overflow: hidden;
    }
    .accent { width: 30px; height: 30px; background: var(--accent-color); border-radius: 6px; position: absolute; }
    .accent.tl { top: 10px; left: 10px; } .accent.br { bottom: 10px; right: 10px; }

    #header {
      height: 90px; border-bottom: 1px solid rgba(0,0,0,0.3);
      display: flex; align-items: center; padding: 10px 20px; gap: 14px;
    }
    #header h1 { font-size: 1.4rem; margin: 0; color: #222; }
    #subline { font-size: 0.7rem; color: #333; letter-spacing: 1px; }

    #viewport {
      flex: 1; margin: 20px; border: 3px solid #444; border-radius: 12px;
      background: var(--glass-tint); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
      position: relative; display: flex; flex-direction: column; justify-content: space-between; padding: 16px; gap: 10px;
    }

    .row { display: flex; gap: 10px; align-items: stretch; }
    .col { flex: 1; display: flex; flex-direction: column; gap: 10px; }

    #stats, #times {
      background: rgba(0,0,0,0.25); border: 1px solid #333; border-radius: 10px; padding: 10px;
    }

    .stat {
      font-size: 0.95rem; color: #e7fff7; text-shadow: 0 0 4px rgba(0,255,255,0.8);
      display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px dashed rgba(255,255,255,0.08);
    }
    .stat:last-child { border-bottom: none; }
    .label { color: rgba(200,255,215,0.8); }
    .value { color: #bcfff1; }

    #times .line { display: flex; justify-content: space-between; font-size: 0.9rem; padding: 3px 0; }
    #worldClocks {
      display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 6px; margin-top: 6px;
    }
    .clockBox {
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      padding: 6px; background: rgba(0,0,0,0.25); border: 1px solid #2b2b2b; border-radius: 6px;
      min-height: 44px; text-align:center;
    }
    .clockLabel { font-size: 0.65rem; color:#8af8e5; }
    .clockTime { font-size: 0.85rem; color:#dffdf7; }

    #footer {
      height: 70px; background: linear-gradient(90deg,#4f5152,#656667,#4f5152);
      display:flex; flex-direction:column; justify-content:center; align-items:center; border-top:1px solid rgba(0,0,0,0.3);
    }
    #footer h2 { margin: 0; font-size: 1.0rem; color: #c0c8d0; }
    #footer p { margin: 2px 0 0; font-size: 0.68rem; color: #9aa2ac; text-transform: uppercase; letter-spacing: 2px; }
    #lastUpdated { font-size: 0.6rem; color: #9adccd; margin-top: 4px; }
    #aeBadge {
      width: 50px; height: 50px; border-radius: 50%;
      background: linear-gradient(135deg,#e1e4e6,#c7c9cb,#f9f9fa);
      color:#333; display:flex; align-items:center; justify-content:center;
      font-size:1.2rem; font-weight:bold; border:2px solid #a2a4a8;
      box-shadow: 0 0 0 4px rgba(193,137,69,0.6), inset 0 2px 3px rgba(255,255,255,0.8), inset 0 -2px 3px rgba(0,0,0,0.3);
    }

    /* small screens */
    @media (max-width: 520px) {
      #card { width: 94vw; height: 92vh; }
      #worldClocks { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <div id="card">
    <div class="accent tl"></div>
    <div class="accent br"></div>

    <div id="header">
      <div id="aeBadge">AE</div>
      <div>
        <h1>MIRROR Multipass Card</h1>
        <div id="subline">Launch: <span id="launchDate">--</span> • Days since: <span id="days">--</span></div>
      </div>
    </div>

    <div id="viewport">
      <div class="row">
        <div id="stats" class="col">
          <div class="stat"><span class="label">Holders</span><span id="holders" class="value">--</span></div>
          <div class="stat"><span class="label">Total supply</span><span id="total" class="value">--</span></div>
          <div class="stat"><span class="label">Circulating</span><span id="circ" class="value">--</span></div>
          <div class="stat"><span class="label">Burned</span><span id="burned" class="value">--</span></div>
          <div class="stat"><span class="label">Price</span><span id="price" class="value">--</span></div>
        </div>

        <div id="times" class="col">
          <div class="line"><span class="label">Today</span><span id="currentDate" class="value">--</span></div>
          <div id="worldClocks"></div>
        </div>
      </div>

      <div id="lastUpdated">Last updated: --</div>
    </div>

    <div id="footer">
      <h2>MIRROR</h2>
      <p>Dynamic on-chain dashboard • text/html</p>
    </div>
  </div>

  <script>
    // ====== Config ======
    const TOKEN_ID = '0957ed359f099d5846c2c74c42e7c2eb9608b58c32e320e144840e3efab0b747';
    const LAUNCH_DATE = '2025-03-12T11:19:31Z';
    const POLL_MS = 120_000; // 2 minutes
    const REQUEST_TIMEOUT_MS = 10_000;

    // ====== Utilities ======
    const $ = id => document.getElementById(id);
    const setText = (id, v) => { const n = $(id); if (n) n.textContent = v; };
    const fmtNum = (x) => Number.isFinite(x) ? x.toLocaleString(undefined) : '--';
    const fmtMoney = (x, digits = 4) => Number.isFinite(x) ? x.toFixed(digits) : '--';
    const nowISO = () => new Date().toISOString().replace('T',' ').replace('Z',' UTC');

    function withTimeout(promise, ms, controller) {
      const t = setTimeout(() => controller.abort(), ms);
      return promise.finally(() => clearTimeout(t));
    }

    async function jfetch(url, { signal } = {}) {
      const r = await fetch(url, { signal, headers: { accept: 'application/json' } });
      if (!r.ok) throw new Error(`${r.status} ${url}`);
      return r.json();
    }

    async function retry(fn, { tries = 5, base = 300 } = {}) {
      let last;
      for (let i = 0; i < tries; i++) {
        try { return await fn(); }
        catch (e) {
          last = e;
          await new Promise(res => setTimeout(res, base * (2 ** i) + Math.random() * 100));
        }
      }
      throw last;
    }

    // ====== World clocks ======
    const timeZones = [
      { label: 'UTC', zone: 'UTC' },
      { label: 'New York', zone: 'America/New_York' },
      { label: 'Chicago', zone: 'America/Chicago' },
      { label: 'Los Angeles', zone: 'America/Los_Angeles' },
      { label: 'London', zone: 'Europe/London' },
      { label: 'Paris', zone: 'Europe/Paris' },
      { label: 'Dubai', zone: 'Asia/Dubai' },
      { label: 'Mumbai', zone: 'Asia/Kolkata' },
      { label: 'Beijing', zone: 'Asia/Shanghai' },
      { label: 'Tokyo', zone: 'Asia/Tokyo' },
      { label: 'Sydney', zone: 'Australia/Sydney' }
    ];
    const clockNodes = {};

    function renderClocks() {
      const wrap = $('worldClocks');
      if (!wrap) return;
      wrap.innerHTML = '';
      timeZones.forEach(tz => {
        const box = document.createElement('div');
        box.className = 'clockBox';
        const label = document.createElement('div');
        label.className = 'clockLabel';
        label.textContent = tz.label;
        const time = document.createElement('div');
        time.className = 'clockTime';
        time.id = `clock-${tz.label.replace(/\s+/g,'')}`;
        time.textContent = '--';
        box.appendChild(label);
        box.appendChild(time);
        wrap.appendChild(box);
        clockNodes[tz.label] = time;
      });
    }

    function updateWorldClocks() {
      const now = new Date();
      for (const tz of timeZones) {
        const n = clockNodes[tz.label];
        if (n) {
          n.textContent = now.toLocaleTimeString(undefined, {
            hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: tz.zone
          });
        }
      }
    }

    function updateCurrentDate() {
      const now = new Date();
      setText('currentDate', now.toLocaleDateString(undefined, { year:'numeric', month:'numeric', day:'numeric' }));
    }

    // ====== Stats: Spacescan API ======
    async function holdersCount(signal) {
      // Try aggregate first, fall back to pagination
      // Attempt page 1 to see if an aggregate exists
      const pageSize = 500;
      const baseUrl = `https://api.spacescan.io/token/holders/${TOKEN_ID}`;
      const first = await retry(
        () => jfetch(`${baseUrl}?page=1&page_size=${pageSize}`, { signal }),
        { tries: 5, base: 300 }
      );

      const aggregate = first?.holders_count ?? first?.total_holders ?? first?.total ?? null;
      if (typeof aggregate === 'number' && aggregate > 0) return aggregate;

      // Fallback: collect unique addresses across pages
      const seen = new Set();
      const maxPages = 200;
      let page = 1;
      let data = first;

      while (page <= maxPages) {
        const arr =
          Array.isArray(data?.tokens) ? data.tokens :
          Array.isArray(data?.holders) ? data.holders :
          Array.isArray(data?.data)    ? data.data    : [];

        for (const row of arr) {
          const addr = row?.address ?? row?.holder ?? row?.wallet_address ?? row?.puzzle_hash;
          const amount = Number(row?.amount ?? row?.balance ?? 0);
          if (addr && Number.isFinite(amount) && amount > 0) seen.add(addr);
        }

        if (!arr.length || arr.length < pageSize || data?.next === false || data?.pagination?.has_next === false) break;
        page += 1;

        // fetch next page
        data = await retry(
          () => jfetch(`${baseUrl}?page=${page}&page_size=${pageSize}`, { signal }),
          { tries: 5, base: 300 }
        );
      }

      return seen.size;
    }

    async function fetchStats(signal) {
      const [circ, total, priceXch, xchUsd] = await Promise.all([
        retry(() => jfetch(`https://api.spacescan.io/token/circulating-supply/${TOKEN_ID}`, { signal })),
        retry(() => jfetch(`https://api.spacescan.io/token/total-supply/${TOKEN_ID}`, { signal })),
        retry(() => jfetch(`https://api.spacescan.io/token/price/${TOKEN_ID}?currency=XCH`, { signal })),
        retry(() => jfetch(`https://api.spacescan.io/stats/price?currency=usd`, { signal })),
      ]);

      const circVal  = Number(circ?.circulating_supply ?? 0);
      const totalVal = Number(total?.total_supply ?? 0);
      const burned   = (Number.isFinite(totalVal) && Number.isFinite(circVal)) ? totalVal - circVal : NaN;
      const pxXch    = Number(priceXch?.price?.xch ?? 0);
      const pxUsd    = pxXch * Number(xchUsd?.price ?? 0);

      return { circ: circVal, total: totalVal, burned, priceXch: pxXch, priceUsd: pxUsd };
    }

    async function fetchAndRender() {
      const ac = new AbortController();
      try {
        await withTimeout((async () => {
          const [holders, stats] = await Promise.all([
            holdersCount(ac.signal),
            fetchStats(ac.signal),
          ]);

          setText('holders', fmtNum(holders));
          setText('total',   fmtNum(stats.total));
          setText('circ',    fmtNum(stats.circ));
          setText('burned',  fmtNum(stats.burned));
          // Price: XCH and USD
          const priceOut = (Number.isFinite(stats.priceXch) && stats.priceXch > 0)
            ? `${stats.priceXch.toFixed(8)} XCH ($${fmtMoney(stats.priceUsd)})`
            : '--';
          setText('price', priceOut);

          setText('lastUpdated', `Last updated: ${nowISO()}`);
        })(), REQUEST_TIMEOUT_MS, ac);
      } catch (e) {
        console.error('Update failed:', e);
        // Keep prior values; only update timestamp to reflect attempt
        setText('lastUpdated', `Last attempted: ${nowISO()} (offline or API error)`);
      }
    }

    // ====== Launch + Days since ======
    function renderLaunch() {
      const launch = new Date(LAUNCH_DATE);
      setText('launchDate', launch.toLocaleString(undefined, {
        year:'numeric', month:'numeric', day:'numeric',
        hour:'2-digit', minute:'2-digit', hour12:true, timeZone:'UTC'
      }) + ' UTC');
      const days = Math.floor((Date.now() - launch.getTime()) / 86_400_000);
      setText('days', String(days));
    }

    // ====== Polling control (visibility-aware) ======
    let pollTimer = null;
    function startPolling() {
      if (pollTimer) return;
      pollTimer = setInterval(fetchAndRender, POLL_MS);
    }
    function stopPolling() {
      if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopPolling();
      } else {
        fetchAndRender();
        startPolling();
      }
    });

    // ====== Init ======
    (function init() {
      renderLaunch();
      renderClocks();
      updateCurrentDate();
      updateWorldClocks();

      // tick local time every second
      setInterval(() => { updateCurrentDate(); updateWorldClocks(); }, 1000);

      // first fetch, then start background polling
      fetchAndRender().then(startPolling);
    })();
  </script>
</body>
</html>
```


